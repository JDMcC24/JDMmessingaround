import math
import numpy as np
from matplotlib import pyplot as plt
import itertools

def prod(n):
    #Mulitples elemenst of a list
    product = 1
    for i in n:
        product *= i
    return product

def spradius(A):
    #Input: n x n Matrix, A, as an array
    #Output: spectral radius of A
    if np.shape(A)[0] != np.shape(A)[1]:
        return print( "Error: Input must be a square matrix")
    return max(np.linalg.eig(A)[0])

def is_prime(n):
    #Input: Postiive integer n
    #Output: True if n is prime, False otherwise.
    if n <= 1:
        return print('is_prime Error: Input must be a postive integer.')

    for i in range(2,math.floor(math.sqrt(n))+1,1):
        if n % (i) == 0:
            return False
    return True

def prime_factors(n):
    #Returns list of prime factors of n
    if n <= 1:
        return print("Error: prime_factors requires an integer greater than 1")
    if type(n) != int:
        return print("Error: prime_factors requires an integer greater than 1")

    primes = []
    while n > 1:
        newprimes = []
        for i in range(2, math.ceil(math.sqrt(n))+1):
            if is_prime(i) == True and n%i ==0:
                newprimes.append(i)
        n = n / prod(newprimes)
        primes = primes + newprimes
        if is_prime(n)== True:
            primes.append(int(n))
            break
        
    return sorted(primes)


def next_prime(a):
    #Returns the smallest prime number larger than a
    i = 1
    while is_prime(a+i) == False:
        i+=1
    return a+i

def prime_list(n):
    #Returns all prime numbers less than or equal to n
    #Input: positive integer
    #Output: Array of prime numbers not larger than n
    if n <= 1:
        return print('prime_list Error: Input must be a positive interger.')
    plist = []
    for i in range(2,n+1,1):
        if is_prime(i) == True:
            plist.append(i)
    return plist

def Gblist(n):
    #Input: Positive integer n
    #Output: Pairs of prime number which sum to n, and the number of such pairs

    if n <= 1:
        return print('GBlist Error: Input must be a positive interger larger than 1.')
    glist = []
    num = 0
    for i in prime_list(n):
        if is_prime(n-i) == True:
            pair = (i,n-i)
            glist.append(pair)
            num+= 1
    glist.append(str(num)+ " total pairs" )
    return glist

def Czlist(n):
    #Input: Integer greater than 1
    #Output: Sequence generated by rules of the Collatz conjecture and the number of steps until converges to 1
    if n <= 1:
        return print('Error: Input must be an integer greater than 1.')
    steps = [n]
    while n > 1:
        if n % 2 == 0: 
            n = n/2
            steps.append(n)
            
        elif n%2 == 1:
            n = 3*n+1
            steps.append(n)
    num = len(steps)-1
    return steps, num

def CzPlot(n):
    #Plots Natural numbers not larger than n against how long the Collatz sequence takes to get to 1
    xs = []
    ys = []
    
    for i in range(2,n,1):
        xs.append(i)
        ys.append(Czlist(i)[1])
    plt.scatter(xs,ys,s=5)
    plt.xlabel("Number")
    plt.ylabel("Number of Steps Until 1")
    plt.title( "Collatz Sequences" )
    plt.show()

""" Magic Square Functions"""

def generate_magic_square(n):
    # Magic square generation only works for odd n, 4x4 and 6x6 have specific methods
    if n % 2 == 1:
        return odd_order_magic_square(n)
    elif n % 4 == 0:
        return doubly_even_order_magic_square(n)
    else:
        return singly_even_order_magic_square(n)

def odd_order_magic_square(n):
    # Siamese method for odd n
    magic_square = np.zeros((n, n), dtype=int)
    
    i, j = 0, n // 2
    for num in range(1, n*n + 1):
        magic_square[i, j] = num
        new_i, new_j = (i-1) % n, (j+1) % n
        if magic_square[new_i, new_j]:
            i += 1
        else:
            i, j = new_i, new_j
            
    return magic_square

def doubly_even_order_magic_square(n):
    # Algorithm for doubly even n (n = 4, 8, 12, etc.)
    magic_square = np.arange(1, n*n+1).reshape(n, n)
    
    # Invert certain parts
    for i in range(n):
        for j in range(n):
            if (i % 4 == j % 4) or (i % 4 + j % 4 == 3):
                magic_square[i, j] = n*n + 1 - magic_square[i, j]
                
    return magic_square

def singly_even_order_magic_square(n):
    # Algorithm for singly even n (n = 6, 10, etc.)
    half_n = n // 2
    sub_square = odd_order_magic_square(half_n)
    magic_square = np.zeros((n, n), dtype=int)
    
    # Build blocks
    for i in range(half_n):
        for j in range(half_n):
            magic_square[i, j] = sub_square[i, j]
            magic_square[i + half_n, j] = sub_square[i, j] + 2 * half_n**2
            magic_square[i, j + half_n] = sub_square[i, j] + 3 * half_n**2
            magic_square[i + half_n, j + half_n] = sub_square[i, j] + half_n**2
    
    # Special swapping rules
    if n > 2:
        k = (n - 2) // 4
        for i in range(half_n):
            for j in range(k):
                magic_square[i, j], magic_square[i + half_n, j] = magic_square[i + half_n, j], magic_square[i, j]
        for i in range(half_n):
            for j in range(n - k, n):
                magic_square[i, j], magic_square[i + half_n, j] = magic_square[i + half_n, j], magic_square[i, j]
        magic_square[[0, half_n], [0, k]] = magic_square[[half_n, 0], [0, k]]
    
    return magic_square
    
    
def is_palindrome(num):
    num_str = str(num)
    return num_str == num_str[::-1]

def count_digits(n):
    #Counts number of digits in n
    n_string = str(n)
    return len(n_string)

def Fibonacci_list(n):
    #creates a list of the first n > 2 Fibonacci numbers
    F_list = [1, 1] 
    while len(F_list) < n:
        F_list.append( F_list[-1] + F_list[-2])
    return F_list

def factor_list(n):
    #lists all the factors of n less than n
    f_list = [1]
    for i in range(2, math.floor(math.sqrt(n))+1):
        if n % i == 0:
            f_list.append(i)
            if n/i != i:
                f_list.append(int(n/i))
    return f_list



def is_amicable(a,b):
    a_factors = factor_list(a)
    if sum(a_factors) == b:
        b_factors = factor_list(b)
        if sum(b_factors) == a:
            return True
        else:
            return False
    else:
        return False
    
def is_abundant(n):
    if sum(factor_list(n)) > n:
        return True
    else:
        return False
    


def sum_of_abundants(n):
    answr = False
    for i in range(1,math.floor(n/2)+1):
        if is_abundant(i):
            if is_abundant(n-i):
                answr = True
                break
    return answr


def totient(n):
    answr = 0
    for i in range(1,n):
        if math.gcd(n,i) == 1:
            answr+=1
    return answr

def digit_permutations(num):
    # Convert the number to a string to extract digits
    digits = str(num)
    permutations = set(int("".join(p)) for p in itertools.permutations(digits))
    return sorted(permutations)

